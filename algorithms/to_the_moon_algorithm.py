from algorithms.base_algorithm import Algorithm
import pandas as pd
import numpy as np
from typing import List, Dict, Optional


class ToTheMoonAlgorithm(Algorithm):
    def __init__(
        self,
        atr_period=5,
        bb_period=21,
        bb_deviation=1.00,
        use_atr_filter=True,
        show_signals=True,
    ):
        self.atr_period = atr_period
        self.bb_period = bb_period
        self.bb_deviation = bb_deviation
        self.use_atr_filter = use_atr_filter
        self.show_signals = show_signals

    def calculate_follow_line(self, df):
        df = df.copy()
        df["sma"] = df["close"].rolling(self.bb_period).mean()
        df["stdev"] = df["close"].rolling(self.bb_period).std()
        df["BBUpper"] = df["sma"] + (df["stdev"] * self.bb_deviation)
        df["BBLower"] = df["sma"] - (df["stdev"] * self.bb_deviation)
        df["atrValue"] = self.compute_atr(df)

        n = len(df)
        follow_line = [np.nan] * n
        i_trend = [0] * n
        buy = [np.nan] * n
        sell = [np.nan] * n

        for i in range(n):
            if i == 0:
                continue

            bb_signal = 0
            if df["close"].iloc[i] > df["BBUpper"].iloc[i]:
                bb_signal = 1
            elif df["close"].iloc[i] < df["BBLower"].iloc[i]:
                bb_signal = -1

            new_follow = follow_line[i - 1]

            if bb_signal == 1:
                new_follow = (
                    df["low"].iloc[i] - df["atrValue"].iloc[i]
                    if self.use_atr_filter
                    else df["low"].iloc[i]
                )
                if not np.isnan(follow_line[i - 1]) and new_follow < follow_line[i - 1]:
                    new_follow = follow_line[i - 1]

            elif bb_signal == -1:
                new_follow = (
                    df["high"].iloc[i] + df["atrValue"].iloc[i]
                    if self.use_atr_filter
                    else df["high"].iloc[i]
                )
                if not np.isnan(follow_line[i - 1]) and new_follow > follow_line[i - 1]:
                    new_follow = follow_line[i - 1]

            follow_line[i] = new_follow
            prev_fl = follow_line[i - 1]
            curr_fl = follow_line[i]
            i_trend[i] = (
                i_trend[i - 1]
                if np.isnan(prev_fl)
                else (
                    1
                    if curr_fl > prev_fl
                    else -1 if curr_fl < prev_fl else i_trend[i - 1]
                )
            )

            if i_trend[i - 1] == -1 and i_trend[i] == 1:
                buy[i] = 1.0
            if i_trend[i - 1] == 1 and i_trend[i] == -1:
                sell[i] = 1.0

        shapes_buy = [np.nan] * n
        shapes_sell = [np.nan] * n

        if self.show_signals:
            for i in range(n):
                if buy[i] == 1.0:
                    shapes_buy[i] = follow_line[i] - df["atrValue"].iloc[i]
                if sell[i] == 1.0:
                    shapes_sell[i] = follow_line[i] + df["atrValue"].iloc[i]

        df["Follow Line"] = follow_line
        df["Buy"] = shapes_buy
        df["Sell"] = shapes_sell
        df.drop(
            ["sma", "stdev", "BBUpper", "BBLower", "atrValue"], axis=1, inplace=True
        )
        return df

    def create_trend_segments(self, data):
        """
        Generate colored trend segments and signal labels for plotting.

        This method processes the trading signals generated by the follow line algorithm
        and prepares data for visualizing alternating colored line segments and labels.
        Each segment represents a period between buy/sell signals, colored blue for uptrends
        (buy) and red for downtrends (sell). Labels are added at each signal point.

        Args:
            data (pd.DataFrame): The input DataFrame containing OHLCV data.

        Returns:
            Tuple[List[dict], List[dict]]:
                - segments: List of dictionaries with start/end indices, line values, and color.
                - labels: List of dictionaries with position, value, and text ("BUY"/"SELL").
        """
        segments = []
        labels = []
        start_index = None
        current_color = None

        df_result = self.calculate_follow_line(data)
        data = pd.concat([data, df_result[["Follow Line", "Buy", "Sell"]]], axis=1)

        for i in range(len(data)):
            sell_signal = not pd.isna(data.loc[i, "Sell"]) and data.loc[i, "Sell"] != ""
            buy_signal = not pd.isna(data.loc[i, "Buy"]) and data.loc[i, "Buy"] != ""

            if sell_signal or buy_signal:
                if start_index is None:
                    start_index = i
                    current_color = "red" if sell_signal else "blue"
                else:
                    label_text = "SELL" if current_color == "blue" else "BUY"
                    labels.append(
                        {
                            "position": i,
                            "value": data.loc[i, "Follow Line"],
                            "text": label_text,
                        }
                    )

                    segments.append(
                        {
                            "start_index": start_index,
                            "end_index": i - 1,
                            "line_values": data.loc[start_index:i, "Follow Line"]
                            .iloc[:-1]
                            .tolist(),
                            "color": current_color,
                        }
                    )

                    start_index = i
                    current_color = "red" if sell_signal else "blue"

        if start_index is not None:
            segments.append(
                {
                    "start_index": start_index,
                    "end_index": len(data) - 1,
                    "line_values": data.loc[start_index:, "Follow Line"].tolist(),
                    "color": current_color,
                }
            )

        return segments, labels

    def compute_atr(self, df, period=5):
        tr = self.true_range(df)
        return self.rma(tr, period)

    def true_range(self, df):
        close_shifted = df["close"].shift(1)
        c1 = df["high"] - df["low"]
        c2 = (df["high"] - close_shifted).abs()
        c3 = (df["low"] - close_shifted).abs()
        tr = pd.concat([c1, c2, c3], axis=1).max(axis=1)
        return tr

    def rma(self, series, period):
        return series.ewm(alpha=1 / period, adjust=False).mean()

    def get_last_signal(self, data: pd.DataFrame) -> Optional[str]:
        """
        Returns the last signal ("BUY" or "SELL") from the algorithm's logic.

        Args:
            data (pd.DataFrame): The input DataFrame containing the data.

        Returns:
            Optional[str]: The last signal, either "BUY", "SELL", or None if no signal is found.
        """
        _, labels = self.create_trend_segments(data)
        if not labels:
            return None
        return labels[-1]["text"]

    def simulate_potential_profit(self, segments: List[Dict], labels: List[Dict]) -> float:
        """
        Simulate a trading strategy where we buy at the start of blue segments
        and sell at the start of red segments.

        Starting amount: $100
        - Buy: Uses entire available balance to purchase the asset.
        - Sell: Converts asset back into USD at the selling price.

        Args:
            segments (List[Dict]): A list of trading segments.
            labels (List[Dict]): A list of buy/sell signals with positions and values.

        Returns:
            float: Final account balance after simulated trades.
        """
        balance = 100  # Start with $100
        asset_quantity = 0  # Start with no assets

        for label in labels:
            price_at_signal = label["value"]  # Use Buy/Sell value directly

            if label["text"] == "BUY" and balance > 0:
                # Buy as much as possible with the current balance
                asset_quantity = balance / price_at_signal
                balance = 0  # Fully invested in the asset

            elif label["text"] == "SELL" and asset_quantity > 0:
                # Sell all assets at the current price
                balance = asset_quantity * price_at_signal
                asset_quantity = 0  # Convert all assets back to USD

        # If still holding asset at the end, sell at the last available price
        if asset_quantity > 0:
            # Use the last label's value as the exit price
            last_price = labels[-1]["value"] if labels else 1
            balance = asset_quantity * last_price
            asset_quantity = 0

        return balance
